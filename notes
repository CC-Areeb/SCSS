gulp is the task runner which is going to run our compilation tasks
gulp-sass is the plug-in for gulp to compile our sass
sass package is used by the plug-in 
--save-dev flag means that these packages will be stored in the json file as dev dependancies 
a gulp js file for gulp to run and for compiling sass to css

name has to be like gulpfile.js cuz it works like this .... ðŸ˜…



src, dest, watch, series are the packages we will import for gulp


                            ************************* BIG NOTE *************************

always define your sass coding first and then define your normal css when you want to use the sass components 



Use partials for different sass coding as saving all in 1 file will make is too hard to read and messy
example: @import 'variables'; 
this is how we can import other sass files into our main sass file



using underscore (_) before naming the scss file will make sure that the it will not
compile in a css file as we are only using variables.scss to keep our code 
clean and readable.

This is how we define partials in a nutshell



Mixins:

/*
for small variations we would be duplicating code if not using 
mixins so better use mixins

We use mixins so that common properties can be written down
once in the mixin directive and we only need to write down
if we have variations like underlines or boldness 


we can also define a variable inside the mixin and use that
as a parameter and use it in different variations and have
different outcomes



example:
@mixin button ($some_variable){
    css rule 1
    css rule 2
    css rule 3
    ...

    background-color / color / any rule: $some_variable
}

then where ever we have called in the mixin, we can pass the variables
as the parameter and it will be taken by the mixin

.button-dollar_sign key{
    @include mixin($value); -----> value becauce we are using the "value" keyword for generating color shades
}
*/


& is used to access the properties like &:hover{ ... } 


/*
the key name and css property name must be same

example:
the property name is padding and the map is the values inside it
we have nested the maps here like we have 1 utilities map which
contains the other small maps for different paddig strengths

so that's why we have 4 mini-maps inside 1 big map
*/


Utilities in scss:

Step 1:
Make a file for utilities and import is in the main scss file


Step 2:
make a very big map of multiple utilities
this means that many maps inside a map


Step 3:
use the math library for sass (@use 'sass:math';)


Step 4:
Make a utilities map 
$utilities: (
    a utility set for padding ------------> ("padding": (),)
    a utility set for padding left -------> ("padding-left": (),)
    a utility set for padding right
    a utility set for padding up


    a utility set for margin ------------> ("margin": (),)
    a utility set for margin left -------> ("margin-left": (),)
    a utility set for margin right
    a utility set for margin up
);


Step 5:
make a prefix for padding (p) with the keyword "prefix"


Step 6:
make new property called value which will define all the values
this values properties will also be a map itself
"values:(
    "0 ": $base-padding,
    "1": $base-padding,
    you can add more values 
),"
same will be done for all directions of padding and margin

Note:
Names of these utilites is important as they will match with the 
actual CSS property


Step 7:
generate a sass code to cycle through all the values and make
classes for all of them

code:
@each $property,$map in $utilities {    
    $prefix: map-get($map, "prefix");
    $values: map-get($map, "values");

    @each $key, $val in $values {
        @if ($key == "default"){
            .#{$prefix}{
                #{$property}: $val;
            }
        }

        @else{
            .#{$prefix}-#{$key}{
                #{$property}: $val;
            }
        }
    }
}

defining the key and value pair where the key is property name and value is the map
and utilities is the big map. Next we are getting a prefix for each properties 
through the map-get function and just like that are getting the values



Breakpoints:

/*
make a map for different breakpoints like extra small, small, meduim, large, extra large 
the starting will be at width 0 and goes all the way to 480px in which the small breakpoint 
comes in and when the width reaches to 720px the medium breakpoint will start and so on and
so forth
*/

$breakpoints: (
    "xs": 0,
    "sm": 480px,
    "md": 720px,
    "lg": 960px,
    "xl": 1200px,
);

/** 
Now we make a mixin for all the breakpoints in which the minimum width will be the 
breakpoint of xs or extra-small

the content is used so that the breakpoints can have multiple values depending on
use case
*/

// making a mixin without arguments
@mixin xs {
    @media (min-width: map-get($breakpoints, "xs"))
    {
        @content;
    }
}



GRID SYSTEM:
firstly define some basic container styles and row styles as all the columns go inside the row
and the whole system has its own container for it. Then we added column classes and cycled
through them using the for loop where it will start from 1 and loop through till the number of 
columns we want, in this case we went for 12. we can use multiple grid classes inside the sigle
div class and the grid will work.


GAP:
there are gaps between each column item and we did that by using the each loop in which we 
cycled through the keys and values of the gap map, these gaps will be added to any direct 
child element as long as they have the grid classes.



EXTEND:
With the @extend directive we can reuse other style classes inside another class and it helps us
by writing the code only once and reusing it where ever we want

a mixin uses arguments whereas the extend doesn't and you only have to type the class or id name 
after the @extend keyword

sample:

@extend .myClass

however every time you compile your output css, this class will be added eventhough we have only
made it for a small use and don't need it as a class so we can replace the dot with % sign

@extend %myClass

this will make this a placholder class and will not be used in the output css